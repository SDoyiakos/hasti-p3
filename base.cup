/**********************************************************************
 Java CUP specification for a parser for base programs
 **********************************************************************/

import java_cup.runtime.*;
import java.util.*;

/* The code below redefines method syntax_error to give better error messages
 * than just "Syntax error"
 */
parser code {:

public void syntax_error(Symbol currToken) {
    if (currToken.value == null) {
        ErrMsg.fatal(0,0, "Syntax error at end of file");
    }
    else {
        ErrMsg.fatal(((TokenVal)currToken.value).lineNum,
                     ((TokenVal)currToken.value).charNum,
                     "Syntax error");
    }
    System.exit(-1);
}
:};


/* Terminals (tokens returned by the scanner) */
terminal                INTEGER;
terminal                LOGICAL;
terminal                VOID;
terminal                TUPLE;
terminal TokenVal 	TRUE;
terminal TokenVal	FALSE;
terminal IdTokenVal     ID;
terminal IntLitTokenVal INTLITERAL;
terminal StrLitTokenVal STRLITERAL;
terminal                LCURLY;
terminal                RCURLY;
terminal                LPAREN;
terminal                RPAREN;
terminal                LSQBRACKET;
terminal                RSQBRACKET;
terminal                COLON;
terminal                COMMA;
terminal                DOT;
terminal                INPUTOP;
terminal                OUTPUTOP;
terminal                ASSIGN;
terminal                PLUSPLUS;
terminal                MINUSMINUS;
terminal                PLUS;
terminal                MINUS;
terminal                TIMES;
terminal                DIVIDE;
terminal                AND;
terminal                OR;
terminal                NOT;
terminal                EQUALS;
terminal                NOTEQUALS;
terminal                GREATER;
terminal                GREATEREQ;
terminal                LESS;
terminal                LESSEQ;
terminal                IF;
terminal                ELSE;
terminal                WHILE;
terminal                READ;
terminal                WRITE;
terminal                RETURN;


/* Nonterminals
 *
 * NOTE: You will need to add more nonterminals to this list as you
 *       add productions to the grammar below.
 */
non terminal ProgramNode      program;
non terminal LinkedList       declList;
non terminal DeclNode         decl;
non terminal VarDeclNode      varDecl;
non terminal TypeNode         type;
non terminal IdNode           id;
non terminal TupleDeclNode    tupleDecl;
non terminal LinkedList       tupleBody;
non terminal FctnDeclNode     fctnDecl;
non terminal FctnBodyNode     fctnBody;
non terminal CallExpNode      fctnCall;
non terminal LinkedList	      stmtList;
non terminal FormalsListNode  formals;
non terminal LinkedList	      varDeclList;
non terminal ExpNode	      term;
non terminal ExpNode	      exp;
non terminal AssignExpNode    assignExp;
non terminal LinkedList       loc;
non terminal StmtNode	      stmt;

/* NOTE: Add precedence and associativity declarations here (precedence goes from lowest at top
   	 to highest at bottom) */

precedence right ASSIGN;
precedence left OR;
precedence left AND;
precedence nonassoc GREATER, GREATEREQ, LESS, LESSEQ, EQUALS, NOTEQUALS;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence right NOT;

start with program;


/* Grammar with actions
 *
 * NOTE: add more grammar rules below
 */
program         ::= declList: d
                {: RESULT = new ProgramNode(new DeclListNode(d));
                :}
                ;

declList        ::= declList:dl decl:d
                {: dl.addLast(d);
                   RESULT = dl;
                :}
                | /* epsilon */
                {: RESULT = new LinkedList<DeclNode>();
                :}
                ;

decl            ::= varDecl:v
                {: RESULT = v;
                :}
		| tupleDecl:t
		{:
		RESULT = t;
		:}
		| fctnDecl:f
		{:
		RESULT = f;
		:}
                ;

varDecl         ::= type:t id:i DOT
                {:
		RESULT = new VarDeclNode(t, i, VarDeclNode.NON_TUPLE);
                :}
		| TUPLE id:i1 id:i2 DOT
		{:
		TupleNode tNode = new TupleNode(i1);
		RESULT = new VarDeclNode(tNode, i2, 1);
		:}
                ;

varDeclList	::= varDeclList:l varDecl:v
		{:
		l.add(v);
		RESULT = l;
		:}
		| /* epsilon */
		{:
		LinkedList<VarDeclNode> list = new LinkedList<VarDeclNode>();
		RESULT = list;
		:}
		;

type            ::= LOGICAL
                {: RESULT = new LogicalNode();
                :}
		|
		INTEGER
		{: RESULT = new IntegerNode();
		:}
		|
		VOID
		{: RESULT = new VoidNode();
		:}
                ;


id              ::= ID:i
                {: RESULT = new IdNode(i.lineNum, i.charNum, i.idVal);
                :}
                ;
				
tupleDecl       ::= TUPLE id:i LCURLY tupleBody:b RCURLY DOT                  
                {:							      
		DeclListNode decl = new DeclListNode(b);		      
                RESULT = new TupleDeclNode(i, decl);      		      
                :}                                         		      
                ;							      
                							      
tupleBody	::= tupleBody:body varDecl:v				      
		{:							      
		body.add(v);						      
		RESULT = body;						      
		:}							      
		| varDecl:v						      
		{:							      
		LinkedList<VarDeclNode> nodes = new LinkedList<VarDeclNode>();
		nodes.add(v);						      
		RESULT = nodes;						      
		:}							      
		;							      

fctnCall	::= id:i LPAREN RPAREN
		{:
		RESULT = new CallExpNode(i,null);
		:}
		;

fctnDecl	::= type:t id:i formals:f fctnBody:b
		{:
		RESULT = new FctnDeclNode(t,i,f,b);
		:}
		;

fctnBody	::= LSQBRACKET varDeclList:v stmtList:s RSQBRACKET
		{:
		DeclListNode vars = new DeclListNode(v);
		StmtListNode stmts = new StmtListNode(s);
		RESULT = new FctnBodyNode(vars, stmts);
		:}
		;
		
stmtList	::= stmtList:l stmt:s
		{:
		l.add(s);
		RESULT = l;
		:}
		|
		/* epsilon */
		{:
		LinkedList<StmtNode> list = new LinkedList<StmtNode>();
		RESULT = list;
		:}
		;

stmt		::= RETURN exp:e DOT
		{:
		RESULT = new ReturnStmtNode(e);
		:}
		| RETURN DOT
		{:
		RESULT = new ReturnStmtNode(null);
		:}
		;


formals		::= LCURLY RCURLY
		{:
		RESULT = new FormalsListNode(new LinkedList<FormalDeclNode>());
		:}
		;

exp		::= term:t
		{: RESULT = t;
		:}
		;
		
term		::= TRUE:t
		{:
		RESULT = new TrueNode(t.lineNum,t.charNum);
		:}
		| FALSE:t
		{:
		RESULT = new FalseNode(t.lineNum,t.charNum);
		:}
		| INTLITERAL:t
		{:
		RESULT = new IntLitNode(t.lineNum,t.charNum,t.intVal);
		:}
		| STRLITERAL:t
		{:
		RESULT = new StringLitNode(t.lineNum,t.charNum,t.strVal);
		:}
		| LPAREN exp:e RPAREN
		{:
		RESULT = e;
		:}
		| fctnCall:f
		{:
		RESULT = f;
		:}
		;


loc		::= id:i
		{:
		LinkedList<IdNode> ids = new LinkedList<IdNode>();
		ids.add(i);
		RESULT = ids;
		:}
		| loc:l COLON id:i
		{:
		l.add(i);
		RESULT = l;
		:}
		;
